1. Что такое поток ввода-вывода?

[2.2.1. Ввод-вывод 1.0. Потоки ввода-вывода](https://job4j.ru/profile/exercise/45/task-view/1018)

[2.2.1. Ввод-вывод 0.1. FileOutputStream.](https://job4j.ru/profile/exercise/45/task-view/306)

[2.2.1. Ввод-вывод 0.2. FileInputStream](https://job4j.ru/profile/exercise/45/task-view/307)

[Ввод-вывод Wiki](https://ru.wikipedia.org/wiki/%D0%92%D0%B2%D0%BE%D0%B4-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4)

Java 9, Полное руководство - Герберт Шилдт. Глава 13 (Раздел "Потоки ввода-вывода"), Глава 21 (Разделы "Классы потоков ввода-вывода")

Поток ввода-вывода - это абстракция для потребления или поставки данных. Потоки ввода-вывода связаны с физическим устройством через базовую систему ввода-вывода в Java.
Благодаря абстракции потоков ввода-вывода все потоки ведут себя одинаково независимо от физического устройства (клавиатуры, консоли, файлов, сети).


---
---
2. Что такое Java IO?

[2.2.1. Ввод-вывод 1.0. Потоки ввода-вывода](https://job4j.ru/profile/exercise/45/task-view/1018)

[Основные отличия Java IO и Java NIO](https://habr.com/ru/post/235585/)

Java 9, Полное руководство - Герберт Шилдт. Глава 21.

[Документация IO](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/package-summary.html)

IO API - абстрактный доступ к вводу-выводу, чтобы не зависеть от подробностей реализации физических устройств.

Поток ввода - это объект, из которого можно считать данные (input) - чтение.

Поток вывода - это объект, в который можно записать данные (output) - запись.

Java IO подразделяется на две основные категории: байтовый (byte-oriented) и символьный (character-oriented) ввод-вывод.

Байтовый ввод-вывод (`java.io`) работает с данными в виде байтов.
Он обеспечивает потоки байтового ввода (`InputStream`) и байтового вывода (`OutputStream`),
которые могут использоваться для чтения и записи данных из и в различные источники, такие как файлы,
сетевые соединения и другие. Байтовые потоки часто используются для работы с необработанными двоичными данными.

Символьный ввод-вывод (`java.io`) работает с данными в виде символов, используя стандартные наборы символов, такие как Unicode.
Он предоставляет символьные потоки ввода (`Reader`) и вывода (`Writer`), которые могут использоваться для чтения и записи текстовых данных из и в различные источники.
Символьные потоки обеспечивают более высокоуровневые операции, такие как чтение и запись строк или работу с символами вместо байтов.

---
---
3. Что такое Java NIO?

[2.2.1. Ввод-вывод 1.1. Java NIO/NIO.2 API](https://job4j.ru/profile/exercise/45/task-view/1019)

[Основные отличия Java IO и Java NIO](https://habr.com/ru/post/235585/)

Java 9, Полное руководство - Герберт Шилдт. Глава 22.

[Документация NIO](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/package-summary.html)

Новая система Java NIO API использует буферориентированный подход.
Данный подход организует чтение и запись данных с помощью их загрузки в специальные буферы, внутри которых можно перемещаться по данным вперед и назад, тем самым обеспечивается гибкость обработки данных.


---
---
4. Что такое NIO.2?

[2.2.1. Ввод-вывод 1.1. Java NIO/NIO.2 API](https://job4j.ru/profile/exercise/45/task-view/1019)

[Основные отличия Java IO и Java NIO](https://habr.com/ru/post/235585/)

Java 9, Полное руководство - Герберт Шилдт. Глава 22 (Раздел "Усовершенствования в системе NIO.2")

В Java 7 система ввода-вывода NIO была значительно расширена (данное обновление также называют NIO.2).
Были добавлены несколько пакетов и классов, направленных на расширение возможностей применения системы ввода-вывода NIO.
Отдельно можно выделить пакет java.nio.file, его интерфейс Path и классы Paths, Files, которые расширяют возможности манипуляции с файлами (файловый ввод-вывод).

1. Классы `Path` и `Paths`: `Path` представляет путь к файлу или директории в файловой системе, а `Paths` предоставляет методы для создания экземпляров класса `Path`.

2. Улучшенные операции с файлами: NIO.2 включает более удобные методы для чтения, записи и манипулирования файлами.
Например, можно скопировать файлы с помощью метода `Files.copy()`, переименовать или удалить файлы, а также манипулировать атрибутами файлов.

3. Улучшенная поддержка символических ссылок: NIO.2 предоставляет классы для создания и манипуляции символическими ссылками, такие как `LinkOptions` и `Files.createSymbolicLink()`.

4. Поддержка чтения и записи метаданных файлов: NIO.2 предоставляет класс `BasicFileAttributes`, который содержит информацию о файле, такую как дата создания, последнего доступа, последней модификации и т. д.

5. Асинхронные операции ввода-вывода: NIO.2 поддерживает асинхронные операции чтения и записи файлов, позволяя эффективно использовать ресурсы системы и обрабатывать множество операций одновременно.


---
---
5. Что такое Scanner?

[2.2.1. Ввод-вывод 7. Scanner](https://job4j.ru/profile/exercise/45/task-view/786)

Java 9, Полное руководство - Герберт Шилдт. Глава 20 (Раздел "Класс Scanner")

[Документация Scanner](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html)

В Java класс `Scanner` представляет собой удобный инструмент для чтения данных.


---
---
6. Как работает Scanner внутри?

[2.2.1. Ввод-вывод 7. Scanner](https://job4j.ru/profile/exercise/45/task-view/786)

Java 9, Полное руководство - Герберт Шилдт. Глава 20 (Раздел "Класс Scanner")

[Документация Scanner](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html)

В качестве источника данных Scanner принимает любой вид данных, включая Reader, InputStream, File для java.io и Readable, Path для java.util.nio.
Также можно задать источник в виде строки String.

Работает как итератор.

---
---
7. Какие базовые методы существуют в Scanner?

[2.2.1. Ввод-вывод 7. Scanner](https://job4j.ru/profile/exercise/45/task-view/786)

Java 9, Полное руководство - Герберт Шилдт. Глава 20 (Раздел "Класс Scanner")

[Документация Scanner](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html)

Большинство методов можно разделить на hasTYPE и nextTYPE, где TYPE - это тип по шаблону которого будет происходить отделение токенов друг от друга.
Например, hasInt(), nextInt().

---
---
8. Что такое байтовый поток? Как он реализован внутри?

[2.2.1. Ввод-вывод 1.0. Потоки ввода-вывода](https://job4j.ru/profile/exercise/45/task-view/1018)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Потоки ввода-вывода байтов", "Класс InputStream", "Класс OutputStream" и остальные).

[Документация InputStream](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/InputStream.html)

[Документация OutputStream](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/OutputStream.html)

Байтовые потоки предоставляют средства ввода-вывода отдельных байтов, например, чтения и записи двоичных данных.

В основе байтовых потоков лежат абстрактные классы InputStream и OutputStream (потоки ввода и вывода соответственно).
Каждый из этих классов имеет свои классы-реализации, которые учитывают особенности разных устройств (файлов на диске, сетевых соединений, буферов памяти и т.д.).

Основные классы-реализации InputStream (потоки ввода):

    - ByteArrayInputStream - читает байты из массива

    - FileInputStream - читает данные из файла

    - ObjectInputStream - поток ввода объектов

    - PipedInputStream - канал ввода

    - FilterInputStream - реализует класс InputStream. От него реализуются следующие 3 класса:

            - BufferedInputStream - буферизированный поток ввода

            - DataInputStream - читает данные примитивных типов

            - PushbackInputStream - поток ввода, поддерживающий возврат одного байта обратно в поток ввода



Основные классы-реализации OutputStream (потоки вывода):

    - ByteArrayOutputStream - записывает байты в массив

    - FileOutputStream - записывает данные в файл

    - ObjectOutputStream - поток вывода объектов

    - PipedOutputStream - канал вывода

    - PrintStream - поток вывода, содержащий методы print() и println()

    - FilterOutputStream - реализует класс OutputStream. От него реализуются следующие 2 класса:

            - BufferedOutputStream - буферизированный поток вывода

            - DataOutputStream - записывает данные примитивных типов



Важно! Все классы, имеющие в названии InputStream/OutputStream читают/пишут данные побайтово.

---
---
9. Что такое символьный поток? Как он реализован внутри?

[2.2.1. Ввод-вывод 1.0. Потоки ввода-вывода](https://job4j.ru/profile/exercise/45/task-view/1018)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Разделы "Потоки ввода-вывода символов", "Класс Reader", "Класс Writer" и остальные)

[Документация Reader](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Reader.html)

[Документация Writer](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Writer.html)

Символьные потоки предоставляют средства ввода-вывода отдельных символов. В них применяется кодировка Юникод.
Читать данные по байтам в большинстве случаев неудобно, поэтому были введены символьные потоки, которые во многих случаях более эффективны, чем байтовые, так как считывают целиком символы, а не байты.
Но на низком уровне весь ввод-вывод в java все равно имеет байтовую организацию.

В основе символьных потоков лежат абстрактные классы Reader и Writer (потоки ввода и вывода соответственно).
Каждый из этих классов также имеет свои классы-реализации, которые учитывают особенности разных устройств (файлов на диске, сетевых соединений, буферов памяти и т.д.).

Основные классы-реализации Reader (потоки ввода символов):

    - BufferedReader - буферизированный поток ввода символов

    - CharArrayReader - читает символы из массива

    - PipedReader - канал ввода

    - StringReader - читает символы из строки

    - FilterReader - фильтрованный поток чтения. От этого класса наследуется класс PushbackReader:

            - PushbackReader - поток ввода, позволяющий вернуть считанные символы обратно в поток ввода

    - InputStreamReader - преобразует байты в символы. От этого класса наследуется класс FileReader:

            - FileReader - читает символы из файла


Основные классы-реализации Writer (потоки вывода символов):

    - BufferedWriter - буферизированный поток вывода символов

    - CharArrayWriter - записывает символы в массив

    - PipedWriter - канал вывода

    - StringWriter - записывает символы в строку

    - FilterWriter - фильтрованный поток записи.

    - PrintWriter - поток вывода, содержащий методы print() и println()

    - OutputStreamWriter - преобразует символы в байты. От этого класса наследуется класс FileWriter:

            - FileWriter - записывает символы в файл

---
---
10. Что такое буферизированный поток?

[2.2.1. Ввод-вывод 5.0. Буферизированные потоки](https://job4j.ru/profile/exercise/45/task-view/1059)

[2.2.1. Ввод-вывод 0.3. BufferedReader.](https://job4j.ru/profile/exercise/45/task-view/308)

[2.2.1. Ввод-вывод 0.4. BufferedOutputStream](https://job4j.ru/profile/exercise/45/task-view/309)


Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Разделы "Буферизированные потоки ввода-вывода байтов", "Класс Reader", "Класс Writer" и остальные)

[Документация BufferedInputStream](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/BufferedInputStream.html)

[Документация BufferedOutputStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/BufferedOutputStream.html)

[Документация BufferedReader](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/BufferedReader.html)

[Документация BufferedWriter](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/BufferedWriter.html)

Буферизированный поток - это стандартный поток, к которому добавлен специальный буфер в памяти, который увеличивает производительность чтения и записи.
Обращение к ресурсу при чтении/записи - это очень затратный процесс, поэтому чем меньше обращений к ресурсу - тем лучше.
Буферизированные потоки - это обёртки обычных потоков с буфером.

---
---
11. Какие классы-обёртки позволяют ускорить чтение/запись за счет использования буфера?

[2.2.1. Ввод-вывод 5.0. Буферизированные потоки](https://job4j.ru/profile/exercise/45/task-view/1059)

[2.2.1. Ввод-вывод 0.3. BufferedReader.](https://job4j.ru/profile/exercise/45/task-view/308)

[2.2.1. Ввод-вывод 0.4. BufferedOutputStream](https://job4j.ru/profile/exercise/45/task-view/309)


Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Разделы "Буферизированные потоки ввода-вывода байтов", "Класс Reader", "Класс Writer" и остальные)

[Документация BufferedInputStream](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/BufferedInputStream.html)

[Документация BufferedOutputStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/BufferedOutputStream.html)

[Документация BufferedReader](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/BufferedReader.html)

[Документация BufferedWriter](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/BufferedWriter.html)

Буферное побайтовое чтение/запись реализовано классами BufferedInputStream и BufferedOutputStream.
Буферное посимвольное чтение/запись реализовано классами BufferedReader и BufferedWriter.

Все buffered* классы являются обёртками и не могут существовать сами по себе.
При создании объектов этих классов в их конструкторы нужно передавать объекты классов-реализаций InputStream/OutputStream.
Могут быть и цепочки обёрток, но в корне всегда должен быть байтовый или символьный поток.

---
---
12. Как осуществляется ввод и вывод из командной строки?

[2.2.1. Ввод-вывод 1.0. Потоки ввода-вывода](https://job4j.ru/profile/exercise/45/task-view/1018)

Java 9, Полное руководство - Герберт Шилдт. Глава 13 (Разделы "Предопределенные потоки ввода-вывода", "Чтение данных, вводимых с консоли" и "Запись данных, выводимых на консоль")

System.out - ссылается на стандартный поток вывода (консоль).

System.in - ссылается на стандартный поток ввода (клавиатура).

System.err - ссылается на стандартный поток вывода ошибок (консоль).

---
---
13. Что такое класс Console? Расскажите его АПИ.

[2.2.1. Ввод-вывод 18. Класс Console](https://job4j.ru/profile/exercise/45/task-view/1071)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Класс Console")

[Документация Console](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Console.html)

Класс Console предназначен для работы с консолью - командной строкой Windows или терминалом Linux/MacOS и упрощает работу с ними.
Класс Console определён в пакете java.io.

Доступ к консоли (командной строке) можно получить только из самой командной строки.
Попытка получить объект консоли в любой среде разработки вернёт null, поэтому полученный объект требуется проверять на null.

Методы объекта Console:
   - `readLine()`: Читает строку из командной строки пользователя и возвращает ее.
   - `readPassword()`: Читает пароль (символы не отображаются на экране) из командной строки пользователя и возвращает его в виде массива символов char[].
   - `format()`: Осуществляет форматированный вывод в командную строку с использованием форматной строки и дополнительных аргументов.
   - `writer()`: Получает объект PrintWriter для вывода сообщений в командную строку.
   - `flush()`: Сбрасывает все данные из выводного буфера в командную строку.
   - `printf()`: Осуществляет форматированный вывод в командную строку, аналогичный методу format().

---
---
14. Что такое поток данных? Data stream.

[2.2.1. Ввод-вывод 19. Потоки данных (Data Streams)](https://job4j.ru/profile/exercise/45/task-view/1069)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Классы DataOutputStream и DataInputStream")

[Документация DataInputStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/DataInputStream.html)

[Документация DataOutputStream](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/DataOutputStream.html)


---
---
15. Что такое поток объектов, Object stream.

[2.2.1. Ввод-вывод 21. Потоки объектов. (Object streams)](https://job4j.ru/profile/exercise/45/task-view/1072)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Разделы "Интерфейс ObjectInput", "Класс ObjectInputStream", "Интерфейс ObjectOutput", "Класс ObjectOutputStream")

[Документация ObjectInput](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/ObjectInput.html)

[Документация ObjectInputStream](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/ObjectInputStream.html)

[Документация ObjectOutput](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ObjectOutput.html)

[Документация ObjectOutputStream](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/ObjectOutputStream.html)

Потоки объектов представлены в пакете java.io классами ObjectInputStream и ObjectOutputStream. ObjectOutputStream превращает объект в его байтовое представление.
ObjectInputStream восстанавливает объект из байтового представления в обычное. Эти процессы называются сериализацией и десериализацией соответственно.
С помощью этих операций можно сохранить объект (состояние объекта) в виде последовательности байт, удобной для передачи по сети, и восстановить эту последовательность байт обратно в объект, например, на другом компьютере.

---
---
16. Что такое Path? Как он реализуется на разных ОС?

[2.2.1. Ввод-вывод 9.1. Файлы и директории. Классы Path, Files, Paths](https://job4j.ru/profile/exercise/45/task-view/1016)

[Pathосные новшества JDK7. Работа с файловой системой](https://habr.com/ru/sandbox/25126/)

Java 9, Полное руководство - Герберт Шилдт. Глава 22 (Раздел "Интерфейс Path")

[Документация Path](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/file/Path.html)

Интерфейс Path определен в пакете java.nio.file, замена File.
Path - это усовершенствованная модель File. Используйте Path

```java
Path path = FileSystems.getDefault().getPath("logs", "access.log");
BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);
```

В параметры метода getPath() передаются части пути отдельными строками.
При создании пути, из этих частей программой будет определен разделитель с помощью метода FileSystem.getSeparator(), и с помощью этого разделителя будет собрана строка.
В данном случае будет определен разделитель той ОС, в которой выполняется программа.

---
---
17. Как получить список файлов?

[2.2.1. Ввод-вывод 9.0. Файлы и директории. Класс File](https://job4j.ru/profile/exercise/45/task-view/313)

[2.2.1. Ввод-вывод 10. Сканирование файловой системы](https://job4j.ru/profile/exercise/45/task-view/314)

[Разбор утилиты Files.walkFileTree();](https://habr.com/ru/post/437694/)


Java 9, Полное руководство - Герберт Шилдт. Глава 22 (Разделы "Перечисление содержимого каталога" и "Перечисление дерева каталогов с помощью метода walkFileTree()")

[Документация Walking The File Tree](https://docs.oracle.com/javase/tutorial/essential/io/walk.html)

[Документация File.list()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#list())

[Документация File.listFiles()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#listFiles())

[Документация Files.walkFileTree()](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/nio/file/Files.html#walkFileTree(java.nio.file.Path,java.nio.file.FileVisitor))

io:

```java
File target = new File("src/main/java/ru/job4j/io/files");
File[] listFiles = target.listFiles();
for (File f : listFiles) {
    System.out.println(f);
}
```

nio:

Нужно использовать интерфейс FileVisitor.
Интерфейс FileVisitor имеет 4 метода. Нас будет интересовать только visitFile. Java последовательно передает в него файлы

```java
Path start = Paths.get(".");
Files.walkFileTree(start, new PrintFiles());
```


---
---
18. Как проверить что файловая сущность является файлом или папкой?

[2.2.1. Ввод-вывод 9.0. Файлы и директории. Класс File](https://job4j.ru/profile/exercise/45/task-view/313)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Класс File")

[Документация File.isFile()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#isFile())

[Документация File.isDirectory()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#isDirectory())

Нужно использовать следующие методы:

```java
file.isDirectory()
file.isFile()
```

---
---
19. Как удалить файл?

[2.2.1. Ввод-вывод 9.0. Файлы и директории. Класс File](https://job4j.ru/profile/exercise/45/task-view/313)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Класс File")

[Документация File.delete()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#delete())

Удалить файл или директорию можно с помощью метода delete(). Каталог можно удалить, только если он пустой!

```java
file.delete();
directory.delete();
```
Также класс File содержит метод deleteOnExit(), который не удаляет файл сразу, а удалит его по завершении работы программы.

```java
file.deleteOnExit();
```

---
---
20. Как переместить файл?

[2.2.1. Ввод-вывод 9.0. Файлы и директории. Класс File](https://job4j.ru/profile/exercise/45/task-view/313)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Класс File")

[Документация File.renameTo()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#renameTo(java.io.File))

[Документация Files.move()](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/file/Files.html#move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...))

До JDK 7 не было готовой возможности переместить файл в другую директорию, но есть 2 варианта как это можно сделать вручную:

- Если переместить нужно содержимое файла, то достаточно применить метод File.renameTo(), то есть просто переименовать его, тем самым достигая результата "перемещения" данных в файл с заданным именем.
Имейте в виду, что этот метод работает не во всех файловых системах, как было указано ранее.

- Если требуется переместить файл в другую директорию, то нужно скопировать содержимое файла в новый файл в другой директории, после чего старый файл удалить.

Начиная с версии JDK 7 появилась возможность переместить файл с помощью метода move():

move(Path source, Path target, CopyOption... options)

---
---
21. Как управлять атрибутами файла?

[2.2.1. Ввод-вывод 9.2. Атрибуты файла](https://job4j.ru/profile/exercise/45/task-view/1021)

[Pathосные новшества JDK7. Работа с файловой системой](https://habr.com/ru/sandbox/25126/)

[Документация FileAttributeView](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/attribute/FileAttributeView.html) (В нем перечислены все подинтерфейсы).

Java 9, Полное руководство - Герберт Шилдт. Глава 22 (Раздел "Интерфейсы атрибутов файлов")



22. Как создать файл?

[2.2.1. Ввод-вывод 9.0. Файлы и директории. Класс File](https://job4j.ru/profile/exercise/45/task-view/313)

[2.2.1. Ввод-вывод 0.1. FileOutputStream.](https://job4j.ru/profile/exercise/45/task-view/306)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Разделы "Класс File" и "Класс FileOutputStream")

[Документация File.createNewFile()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#createNewFile())

[Документация Files.write()](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/file/Files.html#write(java.nio.file.Path,byte%5B%5D,java.nio.file.OpenOption...))

[Документация Files.createFile()](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/file/Files.html#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...))

1) Path
    -  Создать объект Path
        ```java
        Path path = Path.of("path/paths/path.txt");
        ```

    - Создать файл
        ```java
        Files.createFile(path);
        ```

2) FileOutputStream

```java
try (FileOutputStream out = new FileOutputStream("data/dataresult.txt")) {
    out.write("Hello, world!".getBytes());
    out.write(System.lineSeparator().getBytes());
```

3) File

```java
File file = new File("path/to/file/file.txt");
file.createNewFile();
```

---
---
23. Как создать директорию?

[2.2.1. Ввод-вывод 9.0. Файлы и директории. Класс File](https://job4j.ru/profile/exercise/45/task-view/313)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Создание каталогов")

[Документация Files.createDirectories()](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/file/Files.html#createDirectories(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)) (также createDirectory())

[Документация File.mkdirs()](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/File.html#mkdirs()) (также mkdir())

1) Path
    -  Создать объект Path
        ```java
        Path dir = Paths.get("path/paths");
        ```

    - Создать файл
        ```java
        Files.createDirectories(dir);
        ```

3) File

```java
File directory = new File("path/to/dir/");
directory.mkdir();
```

---
---
24. Как записать в файл?

[2.2.1. Ввод-вывод 0.1. FileOutputStream.](https://job4j.ru/profile/exercise/45/task-view/306)

Java 9, Полное руководство - Герберт Шилдт. Глава 13 (Раздел "Запись данных, выводимых на консоль")

[Документация OutputStream](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/OutputStream.html) (методы write())

[Документация Writer](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/Writer.html) (методы write())

1) OutputStream

```java
try (FileOutputStream out = new FileOutputStream("data/dataresult.txt")) {
            out.write("Hello, world!".getBytes());
            out.write(System.lineSeparator().getBytes());
```

2) Writer

```java
try (Writer writer = new FileWriter("output.txt")) {
            String data = "Привет, мир!";
            writer.write(data);
```

---
---
25. Как прочитать данные из файла?

[2.2.1. Ввод-вывод 0.2. FileInputStream](https://job4j.ru/profile/exercise/45/task-view/307)

[2.2.1. Ввод-вывод 7. Scanner](https://job4j.ru/profile/exercise/45/task-view/786)

[Документация Scanner](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html)

Java 9, Полное руководство - Герберт Шилдт. Глава 13 (Разделы "Чтение данных, вводимых с консоли", "Чтение символов" и "Чтение символьных строк"), Глава 20 (Раздел "Класс Scanner").

[Документация Reader](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Reader.html) (методы read())

[Документация BufferedReader](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/BufferedReader.html) (методы read() и readLine())



26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?

[2.2.1. Ввод-вывод 3. Классы вывода PrintStream / PrintWriter](https://job4j.ru/profile/exercise/45/task-view/1079)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Разделы "Класс PrintStream" и "Класс PrintWriter")

[Документация PrintStream](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/PrintStream.html)

[Документация PrintWriter](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/PrintWriter.html)



27. Что такое потоки байтовых массивов? Как они устроены?

[2.2.1. Ввод-вывод 4. Потоки байтовых массивов (ByteArray Streams)](https://job4j.ru/profile/exercise/45/task-view/1078)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Разделы "Класс ByteArrayInputStream" и "Класс ByteArrayOutputStream")

[Документация ByteArrayOutputStream](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/io/ByteArrayOutputStream.html)

[Документация ByteArrayInputStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/ByteArrayInputStream.html)



28. Зачем нужен класс RandomAccessFile?

[2.2.1. Ввод-вывод 20. Файл произвольного доступа. RandomAccessFile](https://job4j.ru/profile/exercise/45/task-view/1080)

Java 9, Полное руководство - Герберт Шилдт. Глава 21 (Раздел "Класс RandomAccessFile")

[Документация RandomAccessFile](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/RandomAccessFile.html)



29. Данные в каком виде можно считывать байтовыми и символьными потоками?

[2.2.1. Ввод-вывод 5.0. Буферизированные потоки](https://job4j.ru/profile/exercise/45/task-view/1059) (в конце)


---
---
30. Что такое сокет?

[2.2.2. Socket 2. Что такое Socket?](https://job4j.ru/profile/exercise/46/task-view/320)

Socket (сокет) – это программный интерфейс, который позволяет программам обмениваться данными через сетевое соединение.
Он предоставляет удобную абстракцию для работы с сетевыми протоколами, такими как TCP/IP или UDP.
С помощью сокетов можно создавать клиент-серверные приложения, где серверный сокет ждет подключения клиентов,
а клиентский сокет устанавливает соединение с сервером.



---
---
31. Какие виды сокетов есть в Java? С каким протоколом они работают?

[2.2.2. Socket 2. Что такое Socket?](https://job4j.ru/profile/exercise/46/task-view/320)

[2.2.2. Socket 1. Протокол HTTP](https://job4j.ru/profile/exercise/46/task-view/906)

Java 9, Полное руководство - Герберт Шилдт. Глава 23 (Разделы "Клиентские сокеты по протоколу TCP/IP" и "Серверные сокеты по протоколу TCP/IP").

[Документация Socket](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/net/Socket.html)

[Документация ServerSocket](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/ServerSocket.html)

В Java есть специальный пакет для работы с сетью: java.net.

java.net.ServerSocket - класс реализует серверный сокет, который ожидает запросы, приходящие от клиентов по сети, и может отправлять ответ.
java.net.Socket - класс реализует клиентский сокет.

Соединение между java - сокетами устанавливается с помощью транспортного протокола TCP.
То есть используя сокеты мы можем передавать и получать информацию по установленному TCP - соединению.

---
---
32. Как отправить через сокет сообщение?

[2.2.2. Socket 2. Что такое Socket?](https://job4j.ru/profile/exercise/46/task-view/320)

[2.2.2. Socket 3. Бот](https://job4j.ru/profile/exercise/46/task-view/321)

[Первое знакомство с протоколом HTTP через написание простейшего Web сервера на Java](https://habr.com/ru/post/441150/)

1) создаём сервер

```java
try (ServerSocket server = new ServerSocket(portNumber))
```

2) Вызов метода accept() заставляет программу ждать подключений по указанному порту, работа программы продолжится только после подключения клиента.
После успешного подключения метод возвращает объект Socket, который используется для взаимодействия с клиентом.

```java
Socket socket = server.accept();
```

3) С помощью объекта socket получаем входной поток и отправляем данные в выходной потоки

```java
try (OutputStream out = socket.getOutputStream();
    BufferedReader in = new BufferedReader(
        new InputStreamReader(socket.getInputStream()))) {
```

4) читаем весь входной поток

```java
for (String str = in.readLine(); str != null && !str.isEmpty(); str = in.readLine()) {
   System.out.println(str);
}
```

5) После чтения отправляем ответ окончательно

```java
out.flush();
```

---
---
33. Что такое логирование?

[2.2.3. Логирование 1. Log4j. Логирование системы.](https://job4j.ru/profile/exercise/47/task-view/322)
[Логирование Wiki](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB_%D0%B6%D1%83%D1%80%D0%BD%D0%B0%D0%BB%D0%B0)

Логирование - это процесс записи в файл полезной информации о работе программы.
Полученный файл называют лог-файлом. Если приложение работает плохо, то первое что проверяют - это лог файл

---
---
34. Какие уровни логирования вы знаете?

[2.2.3. Логирование 1. Log4j. Логирование системы.](https://job4j.ru/profile/exercise/47/task-view/322)
[Документация Log4j](https://logging.apache.org/log4j/2.x/manual/architecture.html) (Раздел "LoggerConfig - Log levels")

TRACE - предназначен для записи наиболее подробной информации в журнал, например, отслеживания потока выполнения программы или отладочной информации.
DEBUG - используется для записи информации, полезной для отладки программы
INFO - используется для записи информации о событиях, которые могут быть полезны для контроля работы программы.
Он может содержать записи о выполненных действиях, основных настройках, успешных завершениях операций и других важных событиях
WARN - используется для записи предупреждений о потенциальных проблемах или событиях, которые могут привести к ошибкам или нежелательным результатам
ERROR - используется для записи критических ошибок, которые приводят к некорректному функционированию программы или прерывают ее работу
FATAL - Записи этого уровня указывают на критические ошибки, при которых невозможно продолжить нормальную работу программы.
OFF - это особый уровень, который позволяет полностью отключить запись логов. Когда установлен уровень логирования OFF, никакие записи не будут регистрироваться в журнале логов, независимо от их типа или уровня

---
---
35. Какая библиотека для логирования используется в курсе? Как ее настроить?

[2.2.3. Логирование 1. Log4j. Логирование системы.](https://job4j.ru/profile/exercise/47/task-view/322)
[2.2.3. Логирование 2. Simple Logging Facade 4 Java.](https://job4j.ru/profile/exercise/47/task-view/323)
[Java logging. Hello World](https://habr.com/ru/post/247647/) (Разделы "Log4j" и "Slf4j")

Использовали 2 варианта:

Log4j:

1) в pom.xml добавить зависимость

<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version> // указать актуальную версию
</dependency>

2) создать файл /src/main/resources/log4j.properties
и указать в нём
log4j.rootLogger=DEBUG, console //Уровень логирования
log4j.appender.console=org.apache.log4j.ConsoleAppender //вывод информации в консоль
log4j.appender.console.layout=org.apache.log4j.PatternLayout //формат записи
log4j.appender.console.layout.ConversionPattern=%d{ISO8601} %5p %c:%M:%L - %m%n //Дата, Уровень сообщения, Класс, метод, строчка, Текст сообщения

3) импортировать библиотеку

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

4) private static final Logger LOG = LogManager.getLogger(ClassName.class.getName());

slf4j:

Позволяет абстрагироваться от конкретных библиотек. Это позволяет придерживаться единого стиля логирования для проектов.

1) в pom.xml добавить зависимость

<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.30</version> // указать актуальную версию
</dependency>

2) импортировать библиотеку

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

3)  private static final Logger LOG = LoggerFactory.getLogger(ClassName.class.getName());

---
---
36. Опишите из каких элементов состоит формат JSON

[2.2.4. Сериализация 2. Формат JSON](https://job4j.ru/profile/exercise/174/task-view/327)
[Что такое JSON — Введение](https://habr.com/ru/sandbox/167077/)
[JSON Wiki](https://ru.wikipedia.org/wiki/JSON)

Примитивные типы данных:
    число (целое или вещественное)
    литералы true, false и null
    строка — символы юникода, заключённые в двойные кавычки

Ссылочные типы данных:
    Объект - заключается в фигурные скобки ({ и }) и содержит разделенный запятой список пар имя/значение.
    Массив - заключается в квадратные скобки ([ и ]) и содержит разделенный запятой список значений.


---
---
37. Как преобразовать POJO в/из json?

[2.2.4. Сериализация 5. Преобразование JSON в POJO. JsonObject](https://job4j.ru/profile/exercise/174/task-view/330)
[POJO Wiki](https://ru.wikipedia.org/wiki/POJO)

0) добавить геттеры
1) JSONObject jsonObject = new JSONObject();
       jsonObject.put("age", person.getAge());
       jsonObject.put("contact", jsonContact);
       jsonObject.put("statuses", jsonStatuses);

Сериализация:

Object object = new Object();
JSONObject jsonObject = new JSONObject(person).toString();

Десериализация:

Person person = new Person();
person.setName(jsonObject.getString("name"));
person.setAge(jsonObject.getInt("age"));

---
---
38. Опишите из каких элементов состоит формат XML

[2.2.4. Сериализация 3. Формат XML](https://job4j.ru/profile/exercise/174/task-view/328)
[Что такое XML](https://habr.com/ru/post/524288/)
[XML Wiki](https://ru.wikipedia.org/wiki/XML)

Версия xml
Кодировка
Корневой элемент
Вложенные элементы
Атрибуты
Комментарии

---
---
39. Как преобразовать POJO в/из xml?

[2.2.4. Сериализация 4. JAXB. Преобразование XML в POJO.](https://job4j.ru/profile/exercise/174/task-view/329)

POJO (Plain Old Java Object) — «старый добрый Java-объект», простой Java-объект.

Характеристика POJO:
 - не наследуется от других классов (возможно, кроме POJO-классов того же пакета)
 - не реализует интерфейсов (иногда делается исключение для маркерных интерфейсов из стандартной библиотеки, или тех, которые нужны для бизнес-модели),
 - не использует аннотаций в определениях
 - не зависит от сторонних библиотек.

Преобразование:
0) добавить конструктор по умолчанию
1) Указать корневой тег через аннотацию @XmlRootElement. Эту аннотацию нужно ставить над сущностью, которая будет корневой
2) Над вложенными сущностями нам нужно поставить просто @XmlElement
3) Для того чтобы поле считалось атрибутом нужно поставить  @XmlAttribute, по умолчанию поле парсится как тег


---
---
40. Что такое сериализация / десериализация?

[2.2.4. Сериализация 1. Что такое Сериализация?](https://job4j.ru/profile/exercise/174/task-view/326)
[Сериализация в Java](https://habr.com/ru/post/60317/)
[Сериализация в Java. Не все так просто](https://habr.com/ru/post/431524/)
[Документация Serializable](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html)

Сериализация – процесс преобразования объектов в бинарный (т.е. последовательность битов) или текстовый формат.

Десериализация – процесс преобразования сериализованных данных в объекты, т.е. операция обратная сериализации.

Обычно механизм сериализации/десериализации используется для сохранения состояния программы между запусками, хранения настроек, передачи данных между программами локально или по сети.
В Java существует стандартный механизм сериализации в бинарный формат – Java serialization, из текстовых форматов наиболее популярны JSON, XML, YAML, BSON (binary JSON).

Для стандартной сериализации объекта необходимо в классе имплементировать интерфейс Serializable, этот интерфейс является маркерным,
т.е. нет необходимости реализовывать его методы, он сообщает JVM, что объект нашего класса может быть сериализован.
Для сериализации объектов в поток используется метод writeObject, для чтения из потока readObject класса ObjectOutputStream.

Замечания:
 - Поле serialVersionUID - уникальный идентификатор версии сериализованного класса, необходим для обеспечения механизмов версионности,
    т.е. нужен JVM для понимания, что сериализованный объект при десериализации имеет те же члены класса, методы и пр.
    Если значения не совпадают, будет выброшено исключение java.io.InvalidClassException.

 - При сериализации объекта сериализуются все объекты, на которые он ссылается в своих полях, поэтому вложенные объекты тоже должны быть Serializable

 - Для исключения полей из сериализации используется ключевое слово transient

 - С помощью интерфейса Externalizable можно реализовать собственный алгоритм сериализации/десериализации,
    для этого нужно переопределить два обязательных метода — writeExternal() и readExternal()

---
---
41. Что такое регулярные выражения? Зачем они нужны?
[2.2.1. Ввод-вывод Регулярные выражения. Введение](https://job4j.ru/profile/exercise/45/task-view/997)
[Обработка строк в Java. Часть II: Pattern, Matcher](https://habr.com/ru/post/260773/)
[Регулярные выражения в Java на примере адреса электронной почты](https://habr.com/ru/post/267205/)
Java 9, Полное руководство - Герберт Шилдт. Глава 30 (Раздел "Обработка регулярных выражений")

Регулярные выражения (Regular Expressions или RegEx) - это шаблоны, с помощью которых производится поиск по совпадению в тексте.
То есть это строка, описывающая последовательность символов, которую желаем найти.
С помощью определенного синтаксиса искать можно не только символы напрямую, но и целые диапазоны или комбинации символов.
Тем самым можно создавать самые разнообразные шаблоны для поиска с помощью последовательности обычных символов, метасимволов и квантификаторов.

---
---
42. Как создать регулярное выражение в Java?

[2.2.1. Ввод-вывод Регулярные выражения. Введение](https://job4j.ru/profile/exercise/45/task-view/997)
[Обработка строк в Java. Часть II: Pattern, Matcher](https://habr.com/ru/post/260773/)
[Регулярные выражения в Java на примере адреса электронной почты](https://habr.com/ru/post/267205/)
Java 9, Полное руководство - Герберт Шилдт. Глава 30 (Раздел "Обработка регулярных выражений")

В Java работа с регулярными выражениями производится с помощью классов Pattern и Matcher из пакета java.util.regex.
Эти классы работают в паре. В классе Pattern определяется регулярное выражение (создается шаблон и сопоставитель),
а с помощью класса Matcher производится сопоставление шаблона с текстом.

---
---
43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?

[2.2.1. Ввод-вывод Регулярные выражения. Метасимволы, квантификаторы, классы символов.](https://job4j.ru/profile/exercise/45/task-view/998)
[Обработка строк в Java. Часть II: Pattern, Matcher](https://habr.com/ru/post/260773/)
[Регулярные выражения в Java на примере адреса электронной почты](https://habr.com/ru/post/267205/)
Java 9, Полное руководство - Герберт Шилдт. Глава 30 (Раздел "Обработка регулярных выражений")

Метасимволы - Это специальные символы, позволяющие аккуратнее работать с комбинациями символов.
С помощью них можно искать в начале или конце строки(^ и $), можно задать сколько раз сочетание символов должно встретиться.

Метасимволы разделены на несколько групп:

1) Поиск символов или слов: например, символ "." (точка) соответствует любому одиночному символу, а символы "\w" и "\b" используются для поиска слов.
2) Квантификаторы: например, символы "*" (ноль или более повторений), "+" (одно или более повторений) и "?" (ноль или одно повторение) применяются для указания количества повторений символов.
3) Классы символов: например, символы "\d" (цифры), "\s" (пробелы) и "\w" (буквы, цифры и символ подчеркивания) представляют определенные классы символов.
4) Альтернация: символ "|" (вертикальная черта) используется для указания альтернативных вариантов поиска.
5) Захват групп: символы "(" и ")" используются для создания группировки и захвата определенного фрагмента.

Квантификаторы имеют несколько режимов: жадный, сверхжадный и ленивый.

1) жадный:
Все квантификаторы по умолчанию работают в жадном режиме. Его работа заключается в том, что всегда ищется максимально длинное совпадение.

2) сверхжадный:
Добавляется символ "+", можно использовать когда точно знаем что ищем, и оставшуюся часть можно отбросить

3) ленивый:
Записывается в виде символа "?" после квантификатора. Ленивый режим ищет самую короткую последовательность.

---
---

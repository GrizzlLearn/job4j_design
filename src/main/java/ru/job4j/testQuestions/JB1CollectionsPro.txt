---
---
1) Что такое generic?

Относится к коллекциям. Добавлены в java 1.5
Это запись в вите <T>, которая означает что в коллекцию можно добавить только элементы,
являющиеся экземпляром класса T.
До generic было необходимо делать down-cast от главного типа Object к T.
Если down-cast произвести невозможно - будет ошибка ClassCastException.

---
---
2) Что такое wild cards?

Специальная конструкция, позволяющая более гибко управлять параметризованными типами данных.

---
---
3) Что такое bound wild cards?

Запись вида T<? extends ...> или T<? super ...> — называется bound wildcard, с верхней границей (extends) или
с нижней границей (super).
List<? extends Integer> может содержать объекты, класс которых является Integer или наследуется от Integer.
List<? super Integer> может содержать объекты, класс которых Integer или у которых Integer
является наследником (супертип от Integer).

---
---
4) Что такое unbounded wild cards?

Запись вида T<?> - соответствие любому типу.
Запись выше соответствует записи T<? extends Object> — коллекция может содержать объекты любого класса,
так как все классы в Java наследуются от Object – поэтому подстановка называется неограниченной.

---
---
5) Где хранится информация про Generics?
---
---
6) Как можно получить тип Generics?

Если этот тип был задан явным образом (т.е. параметр определен внутри секции extends одного из наследников).

---
---
7) Что такое итератор?

Это шаблон проектирования, позволяет последовательно получить элементы набора данных.
Итератор описывается интерфейсом java.util.Iterator.
hasNext() проверяет, если ли следующий элемент.
Результат многократного вызова этого метода должен быть одинаковым.
next() возвращает первый элемент ячейки. Второй вызов метода next вернет второй элемент и так далее.
Cдвигает указатель итератора. Указатель - это ссылка на элемент, который нужно вернуть.
Если в итераторе нет элементов и вызывается метод next(), то итератор должен сгенерировать исключение NoSuchElementException.

Шаблон итератор используется в коллекциях, базах данных, чтении файлов.

---
---
8) Что такое коллекции?

Это наборы элементов, которые пришли на замену массивам.

Java Collection Framework включает в себя интерфейсы:
 - Collection - простые последовательные наборы элементов;
 - Map - наборы пар "ключ-значение".

---
---
9) Назовите базовые интерфейсы коллекций?
boolean add(E e) – метод добавляет элемент в коллекцию и возвращает true если добавление выполнено успешно.

boolean addAll(Collection<? extends E> c) – метод добавляет все элементы переданной в метод коллекции в коллекцию, у которой был вызван этот метод.
Метод возвращает true если коллекция, у которой был вызван метод, изменилась.

Iterator<E> iterator() – метод возвращает объект Iterator, который позволяет проходить по элементам нашей коллекции.

boolean remove(Object o) – метод удаляет объект, который мы передали в метод, и возвращает true, если удаление успешно, т.е. коллекция изменилась.

boolean removeAll(Collection<?> c) – метод удаляет все элементы из коллекции, у которой был вызван этот метод, и которые также содержатся в переданной в метод коллекции.
Таким образом после вызова этого метода в коллекции не будет тех элементов, которые содержатся в переданной в метод коллекции.

boolean retainAll(Collection<?> c) – метод, который позволяет сохранить в коллекции только те элементы, которые содержатся в коллекции, которая была передана в метод.
Таким образом в результате в коллекции останутся только те элементы, которые представлены в обоих коллекциях.

int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

Object[] toArray() – метод возвращает массив, который содержит все элементы, содержащиеся в коллекции у которой был вызван этот метод.

Также в интерфейсе определены абстрактные методы equals() и hashcode(), которые не вносят никаких дополнительных условий в контракт методов Object.equals() и Object.hashcode().
Первый предназначен для сравнения коллекций друг с другом, а второй возвращает хэш-код коллекции в виде значения типа int.
Важно, что для коллекций c1 и c2 если выполняется условие c1.equals(c2), то должно выполняться и условие c1.hashcode == c2.hashcode.

---
---
10) Расскажите реализации интерфейса List?
Реализации этого интерфейса представляют собой упорядоченные коллекции,
позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение.

ArrayList:

Является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента.
Поиндексное обращение к элементам выполняется за константное время O(1)

LinkedList:

Позволяет хранить любые данные, включая null.
Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий).
Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1).

Vector:

реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента.
Vector появился в JDK версии Java 1.0, использовать если требуется достижения потокобезопасности.

Stack:

Позволяет хранить любые данные, включая null.
Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий).
Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1).
Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь.


---
---
11) Расскажите реализации интерфейса Set?
Представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные.

HashSet:

Базируется на HashMap. Внутри использует объект HashMap для хранения данных.
В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()).
Из-за особенностей реализации порядок элементов не гарантируется при добавлении.

LinkedHashSet:

Отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap.
Благодаря этому отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов.

TreeSet:

Аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает его поведение.
Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".

---
---
12) Расскажите реализации интерфейса Map?
Представляет из себя справочник, содержит наборы пар "ключ-значение".

Hashtable:

Реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа.

HashMap:

Коллекция является альтернативой Hashtable.
Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения.
Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции.
Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции.
В идеале является константным, но может быть и линейным O(n)

LinkedHashMap:

Это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов.
Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList).
Но это преимущество имеет также и недостаток — увеличение памяти, которое занимает коллекция.

TreeMap:

Реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной.
По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть изменено при помощи объекта Comparator,
который указывается в качестве параметра при создании объекта TreeMap.

WeakHashMap:

Реализация хэш-таблицы, которая организована с использованием weak references.
Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок.

---
---
13) Отличие ArrayList от LinkedList?

— ArrayList реализован внутри в виде обычного массива.
Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в
освободившееся место вставлять новый элемент.
Зато в нем быстро реализованы взятие и изменение элемента – операции get, set, так как в них мы просто обращаемся
к соответствующему элементу массива.

— LinkedList реализован внутри по-другому.
Он реализован в виде связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и
предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей.
А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130.
Другими словами операции set и get тут реализованы очень медленно

---
---
14) Отличие Set от List?

Set - неупорядоченная коллекция, не может содержать дубли
List - упорядоченная коллекция, позволяет хранить дубликаты.
При поиске по значению результатом будет первое найденное вхождение.

---
---
15) Расскажите про методы Object hashCode и equals?

HashCode() и equals() взаимосвязаны, используются для определения равенства между объектами.

Сначала вычисляется hashCode() объектов, т.к. эта операция быстрее equals(). Если hashCode равны, то начинается проверка на equals.
Если hashCode не равны, то дальнейшая проверка на равенство не проводится.

Если x.equals(y) == true, то обязательно hashcode(x) == hashcode(y)
Если hashcode(x) == hashcode(y), то не обязательно x.equals(y) == true

---
---
16) Расскажите, что такое коллизии в Map? Как с ними бороться?

1.1 коллизия вычисления индекса

При вычислении хеш-функции, итоговое значение (номер бакета) у разных ключей может совпадать,
в этом случае применяется метод цепочек (ещё есть метод открытой адрессации):

бакет содержит ссылку на объект, этот объект начинает хранить ссылку на добавляемый объект.

1.2 коллизия хеш-кода

Коллизия происходит в момент добавления объекта.

При коллизии происходит последовательная проверка хешкодов добавляемого ключа с ключами в бакете.
Когда находится ключ с таким же хешкодом, происходит проверка ключей на equals,
если equals = false, объект добавляется в конец линкед листа, если true - старый объект заменяется на новый.

Для борьбы с очень длинными линкед-листами в бакете, начиная с 8 версии линкед-лист преобразовывается в сбалансированное дерево.
Благодаря этому повышается скорость поиска с O(n) до O(log n).

---
---
17) Расскажите, что такое анализ алгоритма?
18) Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? . С чем связаны отличия?
19) Расскажите реализации данных очередей и стеков.
20) Расскажите про реализации деревьев.
21) Что такое loadFactor?
22) Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.
23) Расскажите про операции сдвига. Какие они бывают и что делают?
---
---
24) Как хранится знак числа в Java? Как хранятся отрицательные числа?

Знак хранится в крайнем левом бите. 0 - положительное, 1 - отрицательное.

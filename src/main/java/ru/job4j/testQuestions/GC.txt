#### 1. Чем Java отличается от C++?

[2.4.1. Понятие сборщик мусора 0. Понятие сборки мусора](https://job4j.ru/profile/exercise/58/task-view/369)
[Отличия между C++ /Visual Basic и Java на общем уровне (для начинающих и учащихся)](https://habr.com/ru/post/480112/)

Если кратко:
##### Java
1) код выполняется в JVM + GC
2) легкопортируема благодаря JVM
3) менее быстрый из-за JVM
##### С++
1) ручная работа с памятью
2) зависимость от платформы, необходимость изменений или перекомпиляции
3) быстрый благодаря "близости к железу"

---
---
#### 2. Что такое менеджер памяти?

[Менеджер памяти Wiki](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8)

Это программа обрабатывающая запросы на выделение и освобождение оперативной памяти.

---
---
#### 3. Какой механизм используется в Java для управления памятью?

[2.4.1. Понятие сборщик мусора 0. Понятие сборки мусора](https://job4j.ru/profile/exercise/58/task-view/369)
[HotSpot Wiki](https://ru.wikipedia.org/wiki/HotSpot)
[HotSpot Oracle](https://www.oracle.com/java/technologies/javase/javase-core-technologies-apis.html)

GC

[[3. Понятие сборки мусора (6851)]]

---
---
#### 4. Опишите процесс работы сборщика мусора.

[2.4.1. Понятие сборщик мусора 0. Понятие сборки мусора](https://job4j.ru/profile/exercise/58/task-view/369)
[Избавляемся от мусора в Java](https://habr.com/ru/company/otus/blog/553996/)
[Реализация GC](https://docs.oracle.com/en/java/javase/16/gctuning/garbage-collector-implementation.html)

[[3. Понятие сборки мусора (6851)]]

1. **Minor GC (молодежная сборка)**:
- Этот тип сборки мусора сосредотачивается на молодых объектах, которые только что были созданы и обычно живут недолго. Эти объекты обычно размещаются в поколении молодых объектов (Young Generation).
- В процессе Minor GC происходит сборка мусора внутри поколения молодых объектов. Мертвые объекты удаляются, а выжившие объекты перемещаются в другое подпоколение (например, из Eden Space в Survivor Space).
- Minor GC происходит гораздо чаще, чем Major GC, и его цель - минимизировать простой приложения.

2. **Major GC (старшая сборка)**:
- Этот тип сборки мусора сосредотачивается на объектах, которые считаются "старыми" или "долго живущими".
Эти объекты обычно находятся в поколении старых объектов (Old Generation).
- В процессе Major GC происходит сборка мусора внутри поколения старых объектов.
Этот тип сборки мусора менее часто вызывается, чем Minor GC, и обычно сопровождается более длительным временем простоя приложения.
- Major GC направлен на очистку памяти от объектов, которые прожили длительное время и не были удалены в процессе Minor GC.

---
---
#### 5. Какие алгоритмы сборщика вы знаете?

[2.4.2. Виды сборщиков мусора 0. Виды сборщиков мусора](https://job4j.ru/profile/exercise/59/task-view/371)
[Избавляемся от мусора в Java](https://habr.com/ru/company/otus/blog/553996/)

[[1. Виды сборщиков мусора (6852)#Доступные сборщики мусора]]

---
---
#### 6. Чем отличаются сборщики мусора?

[2.4.2. Виды сборщиков мусора 0. Виды сборщиков мусора](https://job4j.ru/profile/exercise/59/task-view/371)
[Избавляемся от мусора в Java](https://habr.com/ru/company/otus/blog/553996/)
[Дюк, вынеси мусор! — 1. Введение](https://habr.com/ru/post/269621/)(Введение в сборщики и знакомство)
[Дюк, вынеси мусор! — 2. Serial GC и Parallel GC](https://habr.com/ru/post/269707/)(Serial и Parallel)
[Дюк, вынеси мусор! — 3. CMS и G1](https://habr.com/ru/post/269863/)(CMS и G1)
[Дюк, вынеси мусор! — 4. ZGC](https://habr.com/ru/post/680038/)(ZGC)

Различия:
- Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. Такие остановки называются _stop-the-world_ (или _STW_).
- Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, на длительном промежутке времени.
- Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.

---
---
#### 7. Расскажите про утилиты для анализа памяти?

[2.4.2. Виды сборщиков мусора 1. Эксперименты с различными GC](https://job4j.ru/profile/exercise/59/task-view/372)
[2.4.3. Профилирование приложения 0. Инструменты анализа памяти](https://job4j.ru/profile/exercise/60/task-view/373)

[[0. Инструменты анализа памяти (6853)]]

1) jps - показывает pid приложения
2) jmap - позволяет сделать дамп памяти
3) jstat - показывает сводную информацию о состоянии памяти
4) jconsole - имеет окошки наглядно отображает данные
5) visualVM - ещё лучше jconsole

---
---
#### 8. Что такое ссылки?

[2.4.4. Типы ссылок и коллекции на soft weak ссылках 0. Виды ссылок](https://job4j.ru/profile/exercise/61/task-view/375)
[Управление памятью Java](https://habr.com/ru/post/549176/)

[[0. Виды ссылок (6854)]]

Ссылки в Java представляют собой специальные объекты, которые позволяют вам управлять временем жизни других объектов в памяти и взаимодействовать с процессом сборки мусора.
Они используются для отслеживания и контроля доступности объектов в памяти.

---
---
#### 9. Какие типы ссылок Вы знаете?

[2.4.4. Типы ссылок и коллекции на soft weak ссылках 0. Виды ссылок](https://job4j.ru/profile/exercise/61/task-view/375)
[Управление памятью Java](https://habr.com/ru/post/549176/)
[Мягкие ссылки на страже доступной памяти или как экономить память правильно](https://habr.com/ru/post/169883/)
[Документация SoftReference](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ref/SoftReference.html)
[Документация WeakReference](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ref/WeakReference.html)
[Документация PhantomReference](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ref/PhantomReference.html)

1. **Strong Reference (Сильная ссылка)**:
- Сильная ссылка - это наиболее распространенный тип ссылок в Java. Когда объект имеет хотя бы одну сильную ссылку, он считается активным и не подлежит сборке мусора.
- Пример: `Object obj = new Object();`

1. **Soft Reference (Мягкая ссылка)**:
- Мягкая ссылка позволяет объекту существовать до тех пор, пока для него есть доступ через сильные ссылки.
Когда сборщик мусора решает, что память исчерпана, он может начать удалять объекты с мягкими ссылками.
- Пример: `SoftReference<Object> softRef = new SoftReference<>(new Object());`

1. **Weak Reference (Слабая ссылка)**:
- Слабая ссылка также позволяет объекту существовать до тех пор, пока для него есть доступ через сильные ссылки.
Однако, даже если есть слабая ссылка, объект может быть удален сразу при следующей сборке мусора.
- Пример: `WeakReference<Object> weakRef = new WeakReference<>(new Object());`

1. **Phantom Reference (Фантомная ссылка)**:
- Фантомная ссылка позволяет отслеживать, когда объект был удален сборщиком мусора, но не предоставляет доступа к самому объекту.
Она используется в сочетании с ReferenceQueue для выполнения дополнительных действий при удалении объекта.
- Пример: `PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), referenceQueue);`

1. **ReferenceQueue**:
- ReferenceQueue - это специальный механизм, который позволяет отслеживать удаление объектов с помощью слабых и фантомных ссылок.
Когда объект, на который указывает слабая или фантомная ссылка, становится доступным для сборки мусора, ссылка помещается в очередь ReferenceQueue.

---
---
#### 10. Чем эти ссылки отличаются?

[2.4.4. Типы ссылок и коллекции на soft weak ссылках 0. Виды ссылок](https://job4j.ru/profile/exercise/61/task-view/375)
[Управление памятью Java](https://habr.com/ru/post/549176/)
[Мягкие ссылки на страже доступной памяти или как экономить память правильно](https://habr.com/ru/post/169883/)

См. предыдущий ответ

---
---
#### 11. Расскажите про String pool и Integer pool (Integer cache).

[2.4.5. Java Memory Model 1. String pool, Integer pool](https://job4j.ru/profile/exercise/196/task-view/1011)
[Java Challengers #2: Сравнение строк](https://habr.com/ru/company/otus/blog/428449/)(Раздел "Что такое пул строк")
[Знаешь ли ты JAVA, %username%?](https://habr.com/ru/post/111189/)(Вопрос 4)

[[1. String pool, Integer pool (504931)]]

String pool - это специальная область памяти в куче (heap), куда сохраняются только уникальные значения строк.
Строка, созданная с помощью конструктора через ключевое слово new, будет создана непосредственно в heap

Integer pool - В нем хранятся числа от -128 до 127 включительно, то есть пул Integer хранит все числа, которые помещаются в тип byte.
Суть пула Integer в оптимизации, также как и пула строк. Когда мы создаем объекты Integer, то все объекты, входящие в указанный диапазон, будут взяты из пула Integer.
Благодаря пулу Integer системе не придется создавать новые объекты, так как они уже есть в пуле. Этого диапазона чисел достаточно для оптимизации большинства вычислений.

---
---
#### 12. Расскажите о методе String.intern().

[2.4.5. Java Memory Model 1. String pool, Integer pool](https://job4j.ru/profile/exercise/196/task-view/1011)
[Все о String.intern()](https://habr.com/ru/post/79913/)
[Документация String.intern()](https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#intern--)

[[1. String pool, Integer pool (504931)]]

Данный метод гарантирует, что возвращенная ссылка будет указывать на объект, находящийся в пуле строк.
т.е. можно перенести созданную строку heap в srting pool.


---
---
#### 13. Расскажите, что такое профайлер.

[2.4.3. Профилирование приложения 2. Профилировщик Visual VM](https://job4j.ru/profile/exercise/60/task-view/1014)
[2.4.2. Виды сборщиков мусора 1. Эксперименты с различными GC](https://job4j.ru/profile/exercise/59/task-view/372)
[2.4.3. Профилирование приложения 0. Инструменты анализа памяти](https://job4j.ru/profile/exercise/60/task-view/373)

[[2. Профилировщик Visual VM (504934)]]

Пофилировщик (profiler) - это специальная программа, с помощью которой можно оценить где, при выполнении каких операций и в каком количестве потребляются ресурсы при работе нашего приложения.
Профилировщик отслеживает конструкции и операции байт-кода на уровне виртуальной машины Java. Сюда входят создание объекта, выполнение методов, состояние нитей, сборка мусора и т.д.
Также с помощью профайлера можно отслеживать производительность и загрузку ЦП и использование памяти приложением.

---
---
#### 14. Расскажите, как использовать VisualVM.

[2.4.3. Профилирование приложения 2. Профилировщик Visual VM](https://job4j.ru/profile/exercise/60/task-view/1014)
[2.4.2. Виды сборщиков мусора 1. Эксперименты с различными GC](https://job4j.ru/profile/exercise/59/task-view/372)
[Документация VisualVM](https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/intro.html)(Введение в VisualVM)

открывает VisualVM, выбираешь процесс, ожидаешь когда загрузится профайлер, смотришь на данные.

---
---
#### 15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)

[2.4.3. Профилирование приложения 2. Профилировщик Visual VM](https://job4j.ru/profile/exercise/60/task-view/1014)
[Difference between sampling and profiling in jVisualVM](https://stackoverflow.com/questions/12130107/difference-between-sampling-and-profiling-in-jvisualvm)(Stack overflow)

Сэмплинг - это выборка. Запуск выборки работы процесса осуществляется нажатием на кнопку CPU. Сохранить данные можно кнопкой Snapshot.
Выборка по загрузке памяти делается аналогично - нажать кнопку Memory, а после сохранить кнопкой Snapshot.

Профайлин - более точный метод чем сэмплинг блягодаря инструментированию.

Инструментирование - это добавление байткода в существующий байткод, для сбора дополнительной информации о работе методов и тд.

---
---
#### 16. Расскажите о методе finalize().

[2.4.1. Понятие сборщик мусора 0. Понятие сборки мусора](https://job4j.ru/profile/exercise/58/task-view/369)
[Как я пытался понять смысл метода finalize](https://habr.com/ru/post/183344/)
[Опасности метода finalize](https://habr.com/ru/post/130370/)
Д. Блох. Effective Java.(Глава 2, раздел "2.8 Избегайте финализаторов и очистителей")

[[3. Понятие сборки мусора (6851)]]

1. finalize() можно использовать только в двух случаях:
1.1. Проверка/подчистка ресурсов с логированием
1.2. При работе с нативным кодом, который не критичен к утечке ресурсов
2. finalize() замедляет работу GC по очистке объекта в 430 раз
3. finalize() может быть не вызван

---
---
#### 17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

[2.4.5. Java Memory Model 2. Клонирование объектов. Shallow clone и deep clone](https://job4j.ru/profile/exercise/196/task-view/1013)
[Как правильно клонировать объект?](https://habr.com/ru/post/246993/)
[Closures и полное копирование объекта](https://habr.com/ru/post/138594/)
[Документация Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone())

[[2. Клонирование объектов. Shallow clone и deep clone (504933)]]

shallow clone: Если нам нужно создать копию объекта, можно использовать метод clone() класса Object.
Для реализации копирования с помощью clone() класс, копию которого нужно сделать, должен реализовывать интерфейс Cloneable.
Данный интерфейс не содержит никаких методов. Это маркер, сигнализирующий системе о том, что этот класс можно клонировать.

Класс, поля которого содержали только примитивные значения, при поверхностном копировании такого класса будет создан полностью уникальный объект.
Если же в копируемом классе присутствуют поля, которые хранят ссылки на объекты, то в новый объект будут скопированы только сами ссылки на эти объекты, поэтому копирование с помощью метода clone() называется _поверхностным_ _копированием_.

deep clone: Глубокое копирование создает клон, полностью независимый от исходного объекта, то есть изменения в скопированном объекте не повлияют на исходный объект.

все ссылочные типы данных должны реализовывать Cloneable

---
---
#### 18. Расскажите о Stack, Heap и Metaspace.

[2.4.1. Понятие сборщик мусора 1. Stack, Heap, Metaspace](https://job4j.ru/profile/exercise/58/task-view/1012)
[2.1.4. List 4. Используя контейнер на базе связанного списка создать контейнер Stack](https://job4j.ru/profile/exercise/4/task-view/283)
[Управление памятью Java](https://habr.com/ru/post/549176/)(Разделы "Stack" и "Heap")

[[2. Stack, Heap, Metaspace (504932)]]

Стек хранит значения примитивных типов, которые создаются в методах, и ссылки на объекты в heap, на которые ссылаются методы.
Когда в программе вызывается метод, JVM выделяет память в стеке для вызова этого метода. В этой памяти будут храниться значения примитивных типов и ссылки на объекты в куче.
Стек организован по принципу LIFO - Last In First Out (Последним пришел, первым вышел).
При вызове каждого метода, содержащего примитивные типы или ссылки на объекты, в стеке выделяется память, которая хранит эти переменные и ссылки этого метода.
Данные, хранящиеся в этой области памяти, имеют область видимости, которая ограничена телом метода, под который данная часть памяти выделена.
Когда в программе выполняется какой-либо метод, компилятор может получить доступ к переменным только этого метода. (К статическим переменным доступ есть из любого места программы).
При выполнении цепочки методов в момент передачи управления вызываемому методу программа запоминает состояние выполнения текущего метода,
создает новую область памяти в стеке под вызываемый метод, создает там переменные и ссылки вызываемого метода, и передаёт ему управление.
Если в вызываемом методе придется вызывать еще один метод, то эта цепочка действий повторяется.

В heap хранятся сами объекты, под которые динамически выделяется память во время выполнения программы.

Metaspace - Это _отдельная_ область памяти, выделенная под хранение статической информации приложения. Например, метаданные загруженных классов.
Metaspace автоматически расширяется при заполнении. Эта область так же доступна для сборщика мусора, как и heap (сборщик мусора мы будем проходить в следующем уроке).
Сборщик удаляет ненужные классы из памяти, когда область для хранения метаданных заполнена.

---
---
#### 19. Что такое ClassLoader? Перечислите основные реализации ClassLoader.

[2.4.5. Java Memory Model 3. Загрузка классов в JVM](https://job4j.ru/profile/exercise/196/task-view/1053)
[Загрузка классов в Java. Теория](https://habr.com/ru/post/103830/)
[Внутренности JVM, Часть 1 — Загрузчик классов](https://habr.com/ru/company/otus/blog/468193/)

[[3. Загрузка классов в JVM (504973)]]

**ClassLoader** (загрузчик классов) в Java - это механизм, который загружает классы в Java во время выполнения.

1. **Bootstrap ClassLoader**:

    - Это корневой загрузчик классов, который загружает классы из директории `jre/lib` и из JAR-файлов в папке `jre/lib/ext`.
    Он не имеет родительского загрузчика и является самым высоким в иерархии загрузчиков.
2. **Extension ClassLoader**:

    - Этот загрузчик классов наследует от Bootstrap ClassLoader и загружает классы из папки `jre/lib/ext`.
3. **System ClassLoader (Application ClassLoader)**:

    - Этот загрузчик классов загружает классы из CLASSPATH и является родителем для загрузчиков, созданных пользовательским кодом.
    Он загружает классы из директорий и JAR-файлов, указанных в переменной окружения CLASSPATH.
4. **Custom ClassLoaders (Пользовательские загрузчики классов)**:

    - Пользовательский код может создавать собственные загрузчики классов, наследуясь от `java.lang.ClassLoader`.
    Эти пользовательские загрузчики могут загружать классы из разных источников, таких как файлы, базы данных и другие источники.
    Пользовательские загрузчики могут быть полезными, например, при реализации модульной системы.

---
---
#### 20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?

[2.4.5. Java Memory Model 3. Загрузка классов в JVM](https://job4j.ru/profile/exercise/196/task-view/1053)
[Загрузка классов в Java. Теория](https://habr.com/ru/post/103830/)
[Внутренности JVM, Часть 1 — Загрузчик классов](https://habr.com/ru/company/otus/blog/468193/)

[[3. Загрузка классов в JVM (504973)]]

Bootstrap class loader -> Extension / Platform CL -> System / Application CL -> userCustom CL

---
---
#### 21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?

[2.4.5. Java Memory Model 3. Загрузка классов в JVM](https://job4j.ru/profile/exercise/196/task-view/1053)
[Загрузка классов в Java. Теория](https://habr.com/ru/post/103830/)
[Внутренности JVM, Часть 1 — Загрузчик классов](https://habr.com/ru/company/otus/blog/468193/)

Реализация базового загрузчика содержится в самой JVM, поэтому мы не можем её получить. При попытке получения загрузчика класса, который был загружен базовым загрузчиком, мы получим null

---
---
#### 22. Расскажите алгоритм поиска и загрузки класса в JVM.

[2.4.5. Java Memory Model 3. Загрузка классов в JVM](https://job4j.ru/profile/exercise/196/task-view/1053)
[Загрузка классов в Java. Теория](https://habr.com/ru/post/103830/)
[Внутренности JVM, Часть 1 — Загрузчик классов](https://habr.com/ru/company/otus/blog/468193/)

попытка загрузки класса происходит таким образом:
у каждого загрузчика есть список классов, который он уже загружал (кэш). Сначала производится **проверка**, есть ли в кэше загрузчика `System / Application` (в текущем) требуемый класс.
Если его там нет, задача делегируется родителю текущего загрузчика, то есть загрузчику `Extension / Platform`. Если в нём тоже нет, то задача делегируется дальше родителю текущего загрузчика - в загрузчик `Bootstrap`.
Если в кэше какого-либо из этих загрузчиков есть запрашиваемый класс (класс уже был загружен ранее), то возвращается объект Class данного класса, и поиск завершается.
Если ни у одного из этих загрузчиков в кэше нет запрашиваемого класса (то есть этот класс еще не загружался), то начинается попытка **загрузки** запрашиваемого класса в обратном порядке от корневого до текущего.
Сначала загрузчик `Bootstrap` пытается загрузить запрашиваемый класс.
Если в нём его нет, то этот класс пытается загрузить загрузчик `Extension / Platform`, далее `System / Application`, и если ни один из загрузчиков не загрузил запрашиваемый класс, то выбрасывается исключение `ClassNotFoundException`.
Если же класс удалось загрузить какому-либо из загрузчиков, то на этом работа по загрузке этого класса прекращается.
